public:: true
content-origin:: external
content-status:: wip
content-authors:: [[Russ Olsen]]
lang:: en
type:: content

- Topics
	- [[Clojure]]
- Tags
	- [[Book]]
- Publishers
	- [[Pragmatic Bookshelf]]
- #target-audience
	- [[Entry Level Programmer]]
- Read on
	- [[O'Reilly Book]]
		- https://www.oreilly.com/library/view/automating-workflows-with/9781800560406
- #wkf-personal-remarks
	- Pros
		- Easy to follow
		- There are "In the Wild" sections
			- Explain to us about the recently explained stuff in the "real" codebase.
- Table of Contents
	- Part 1: Basics
		- Chapter 1 - Hello, Clojure
		- Chapter 2 - Vectors and Lists
		- Chapter 3 - Maps, Keywords, and Sets
		- Chapter 4 - Logic
		- Chapter 5 - More Capable Functions
		- Chapter 6 - Functional Things
		- Chapter 7 - Let
		- Chapter 8 - Def, Symbols, Vars
		- Chapter 9 - Namespaces
	- Part 2: Intermediate
		- Chapter 10 - Sequences
		- Chapter 11 - Lazy Sequences
		- Chapter 12 - Destructuring
		- Chapter 13 - Records and Protocols
		- Chapter 14 - Tests
		- Chapter 15 - Spec
	- Part 3: Advanced
		- Chapter 16 - Interoperating with Java
		- Chapter 17 - Threads, Promises, and Futures
		- Chapter 18 - State
		- Chapter 19 - Read and Eval
		- Chapter 20 - Macros
		- Chapter 21 - Conclusion
- Chapter 1 - Hello, [[Clojure]]
	- Code snippets
		- ```clojure
		  (ns follow-along.c01-hello-clojure)
		  
		  ;; DO two semiconlons add up to a whole colon?
		  
		  (println "Hello, world!")
		  
		  (str "Clo" "jure")
		  ;; => "Clojure"
		  
		  (str "Hello," " " "world" "!")
		  ;; => "Hello, world!"
		  
		  (str 3 " " 2 " " "Blast off!")
		  ;; => "3 2 Blast off!"
		  
		  
		  (count "Hello, world")
		  ;; => 12
		  
		  (count "Hello")
		  ;; => 5
		  
		  (count "")
		  ;; => 0
		  
		  (println true)
		  (println false)
		  (println "Nobody's home:" nil)
		  (println "we can print many things:" true false nil)
		  
		  ;; Arithmetic
		  
		  (+ 1 2)
		  ;; => 3
		  
		  (* 16 124)
		  ;; => 1984
		  
		  (- 2000 16)
		  ;; => 1984
		  
		  (/ 25792 13)
		  ;; => 1984
		  
		  (/ (+ 1984 2010) 2)
		  ;; => 1997
		  
		  (/ (+ 1984.0 2010) 2)
		  ;; => 1997.0
		  
		  ;; Not variable assignment but close
		  (def first-name "Russ")
		  first-name
		  ;; => "Russ"
		  
		  (def the-average (/ (+ 20 40.0) 2.0))
		  the-average
		  ;; => 30.0
		  
		  ;; a function of your own
		  
		  (defn hello-world []
		    (println "Hello, world!"))
		  (hello-world)
		  
		  (defn say-welcome [what]
		    (println "Welcome to" what))
		  (say-welcome "Clojure")
		  
		  (defn average [a b]
		    (/ (+ a b) 2.0))
		  (average 5.0 10.0)
		  ;; => 7.5
		  
		  (/ 100 0)
		  ;; => Execution error (ArithmeticException) at follow-along.c01/eval8056 (form-init14787553069179530715.clj:75).
		  ;;    Divide by zero
		  ```
- Chapter 2 - Vectors and Lists
	- Vectors and Lists are immutable
	- Code snippets
		- ```clojure
		  (ns follow-along.c02-vectors-and-lists)
		  
		  
		  ;; one thing after another
		  
		  
		  [1 2 3 4]
		  ;; => [1 2 3 4]
		  [1 "two" 3 "four" true]
		  ;; => [1 "two" 3 "four" true]
		  [[1 true 3 "four" 5] 6]
		  ;; => [[1 true 3 "four" 5] 6]
		  
		  
		  ;; A toolkit of functions
		  
		  
		  (vector true 3 "four" 5)
		  ;; => [true 3 "four" 5]
		  
		  (def novels ["Emma" "Coma" "War and Peace"])
		  (count novels)
		  ;; => 3
		  (first novels)
		  ;; => "Emma"
		  (rest novels)
		  ;; => ("Coma" "War and Peace")
		  (into [] (rest novels))
		  ;; => ["Coma" "War and Peace"]
		  (rest (rest novels))
		  ;; => ("War and Peace")
		  
		  (def year-books ["1491","April 1865","1984","2001"])
		  (def third-book (first (rest (rest year-books))))
		  
		  year-books
		  ;; => ["1491" "April 1865" "1984" "2001"]
		  third-book
		  ;; => "1984"
		  (nth year-books 2)
		  ;; => "1984"
		  (year-books 2)
		  ;; => "1984"
		  
		  ;; Growing your vectors
		  novels
		  ;; => ["Emma" "Coma" "War and Peace"]
		  (conj novels "Carrie")
		  ;; => ["Emma" "Coma" "War and Peace" "Carrie"]
		  (cons "Carrie" novels)
		  ;; => ("Carrie" "Emma" "Coma" "War and Peace")
		  
		  
		  ;; Lists
		  
		  
		  '(1 2 3)
		  ;; => (1 2 3)
		  '(1 2 3 "four" 5 "six")
		  ;; => (1 2 3 "four" 5 "six")
		  '([1 2 ("A" "list" "inside a" "vector")] "inside" "a" "list")
		  ;; => ([1 2 ("A" "list" "inside a" "vector")] "inside" "a" "list")
		  (list 1 2 3 "four" 5 "six")
		  ;; => (1 2 3 "four" 5 "six")
		  
		  (def poems `("Iliad" "Odyssey" "Now we are six"))
		  (count poems)
		  ;; => 3
		  (first poems)
		  ;; => "Illiad"
		  (rest poems)
		  ;; => ("Odyssey" "Now we are six")
		  (nth poems 2)
		  ;; => "Now we are six"
		  (conj poems "Jabberwocky")
		  ;; => ("Jabberwocky" "Illiad" "Odyssey" "Now we are six")
		  
		  (def vector-poems ["Iliad" "Odyssey" "Now we are six"])
		  (conj vector-poems "Jabberwocky")
		  ;; => ["Iliad" "Odyssey" "Now we are six"]
		  
		  
		  ;; Staying out of trouble
		  novels
		  ;; => ["Emma" "Coma" "War and Peace"]
		  (conj novels "Jaws")
		  ;; => ["Emma" "Coma" "War and Peace" "Jaws"]
		  novels
		  ;; => ["Emma" "Coma" "War and Peace"]
		  
		  (def more-novels (conj novels "Jaws"))
		  more-novels
		  ;; => ["Emma" "Coma" "War and Peace" "Jaws"]
		  ```
- Chapter 3 - Maps, Keywords, and Sets
	- Maps
		- [[Hash-map]]
		- Maps is also immutable
		- Associative Vectors
			- Vectors and maps have a lot in common. They both associate keys with values, the difference being that with vectors the keys are limited to integers while in maps the keys can be more or less anything. That is, in fact, how Clojure looks at vectors—which means that many of the functions that work with maps will also work with vectors. For example, assoc and dissoc work fine on vectors. Thus `(assoc [:title :by :published] 1 :author)` will give you `[:title :author :published]`.
		- The maps that you create with the literal `{}` or the `hash-map` function make no promises about the order of their keys.
		- Clojure treats commas as whitespace.
	- Keywords
		- Technically, keywords are interned strings, similar to symbols in Ruby and distant cousins to the individual items that go into enumerated types in other languages.
	- Sets
		- Clojure Sets are all about membership
		- Sets have their own ideas about the order of their elements
	- Keep in mind that in expressions like `(:author book)` or `(:sci-fi genres)`, the keywords `:author` and `:sci-fi` aren’t just pretending to be functions. They are functions—functions that look themselves up in a map or a set. It is very common, if a bit confusing to beginners, to see a keyword like `:title` in a context where a function is clearly called for. In those situations, you can bet that there is either a map or a set involved.
	- Wrapping up
		- We are now done with Clojure's basic data structures!
	- Code snippets
		- ```clojure
		  (ns follow-along.c03-maps-keywords-and-sets)
		  
		  ;; This goes with that
		  
		  {"title" "Oliver Twist" "author" "Dickens" "published" 1838}
		  ;; => {"title" "Oliver Twist", "author" "Dickens", "published" 1838}
		  
		  (hash-map "title" "Oliver Twist"
		            "author" "Dickens"
		            "published" 1838)
		  
		  (def book-arc
		    {"title" "Oliver Twist" "author" "Dickens" "published" 1838})
		  (get book-arc "published")
		  ;; => 1838
		  (book-arc "published")
		  ;; => 1838
		  (get book-arc "published?")
		  ;; => nil
		  (book-arc "published?")
		  ;; => nil
		  
		  
		  ;; Keywords
		  
		  
		  :title
		  ;; => :title
		  :author
		  ;; => :author
		  :published
		  ;; => :published
		  :word-count
		  ;; => :word-count
		  :preface&introduction
		  ;; => :preface&introduction
		  :chapter-1-and-2
		  ;; => :chapter-1-and-2
		  
		  
		  (def book
		    {:title "Oliver Twist"
		     :author "Dickens"
		     :published 1838})
		  (str "Title: " (book :title))
		  ;; => "Title: Oliver Twist"
		  (str "By: " (book :author))
		  ;; => "By: Dickens"
		  (str "Published: " (book :published))
		  ;; => "Published: 1838"
		  (str "Published: " (:published book))
		  ;; => "Published: 1838"
		  
		  
		  ;; Changing your map without changing it
		  
		  
		  (assoc book :page-count 362)
		  ;; => {:title "Oliver Twist", :author "Dickens", :published 1838, :page-count 362}
		  book
		  ;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
		  (= book book)
		  ;; => true
		  (= book (assoc book :page-count 362))
		  ;; => false
		  
		  (assoc book :page-count 362 :title "War & Peace")
		  ;; => {:title "War & Peace", :author "Dickens", :published 1838, :page-count 362}
		  (dissoc book :published)
		  ;; => {:title "Oliver Twist", :author "Dickens"}
		  (dissoc book :paperback :illustrator :favorite-zoo-animal)
		  ;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
		  (= book (dissoc book :paperback :illustrator :favorite-zoo-animal))
		  ;; => true
		  
		  ;; Assoc works on vectors too
		  (assoc [:title :by :published] 1 :author)
		  ;; => [:title :author :published]
		  
		  
		  ;; Other handy map functions
		  
		  
		  (keys book)
		  ;; => (:title :author :published)
		  (vals book)
		  ;; => ("Oliver Twist" "Dickens" 1838)
		  
		  
		  ;; Sets
		  
		  
		  
		  (def genres #{:sci-fi :romance :mystery})
		  (def authors #{"Dickens" "Austen" "King"})
		  
		  (contains? authors "Austen")
		  ;; => true
		  (contains? genres "Austen")
		  ;; => false
		  
		  (authors "Austen")
		  ;; => "Austen"
		  (genres :historical)
		  ;; => nil
		  
		  (:sci-fi genres)
		  ;; => :sci-fi
		  (:historical genres)
		  ;; => nil
		  
		  (def more-authors (conj authors "Clarke"))
		  more-authors
		  ;; => #{"King" "Dickens" "Clarke" "Austen"}
		  (disj more-authors "King")
		  ;; => #{"Dickens" "Clarke" "Austen"}
		  
		  
		  ;; Staying out of trouble
		  
		  
		  (= :title "title")
		  ;; => false
		  (= (book "title") (book :title))
		  ;; => false
		  (assoc book "title" "Pride and Prejudice")
		  ;; => {:title "Oliver Twist", :author "Dickens", :published 1838, "title" "Pride and Prejudice"}
		  
		  
		  (book :some-key-that-is-clearly-not-there)
		  ;; => nil
		  
		  
		  (def anonymous-book {:title "The Arabian Nights" :author nil})
		  (anonymous-book :author)
		  ;; => nil
		  (contains? anonymous-book :title)
		  ;; => true
		  (contains? anonymous-book :author)
		  ;; => true
		  (contains? anonymous-book :favorite-color)
		  ;; => false
		  
		  
		  (def possible-authors #{"Austen" "Dickens" nil})
		  (contains? possible-authors "Austen")
		  ;; => true
		  (contains? possible-authors "King")
		  ;; => false
		  (contains? possible-authors nil)
		  ;; => true
		  
		  book
		  ;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
		  (first book)
		  ;; => [:title "Oliver Twist"]
		  (rest book)
		  ;; => ([:author "Dickens"] [:published 1838])
		  (count book)
		  ;; => 3
		  
		  ```
- Chapter 4 - Logic
	- Note that the `=` function is built on the idea of structural equality: roughly, two values are equal according to `=` if they have the same value. Under the hood, `=` is identical to the Java equals method.
	- One issue with having a more or less infinite collection of true things along with two different false things is the terminology. When we say something is `true`, do we mean the specific value `true` or just true in the sense of not being `false` or `nil`? To avoid confusion, Clojurists sometimes refer to the values treated as accurate in the more general sense as being "truthy". Thus, while only `true` is `true`, `"hello"`, `1.0`, and `"Russ"` is all truthy. Similarly, we can use "falsy" to describe the metaphysical quality shared by `nil` and `false`. In Clojure, there are precisely two "falsy"s things—`false` and `nil`—and an infinite number of "truthy" things.
	- Code snippets
		- ```clojure
		  (ns follow-along.c04-logic)
		  
		  ;; The fundamental if
		  
		  
		  (defn print-greeting [preffered-customer]
		    (if preffered-customer
		      "Welcome back to Blotts Books!"
		      "Welcome to Blotts Books!"))
		  
		  (print-greeting true)
		  ;; => "Welcome back to Blotts Books!"
		  (print-greeting false)
		  ;; => "Welcome to Blotts Books!"
		  
		  
		  ;; Asking questions
		  
		  
		  (= 1 1)
		  ;; => true
		  (= 1 2)
		  ;; => false
		  (= 1 1 1 1 1 1 1)
		  ;; => true
		  (= 1 1 1 1 2 1 1)
		  ;; => false
		  
		  (not= 1 1)
		  ;; => false
		  (not= 1 2)
		  ;; => true
		  (not= 1 1 1 1 1 1 1)
		  ;; => false
		  (not= 1 1 1 1 2 1 1)
		  ;; => true
		  
		  (> 1 2)
		  ;; => false
		  (> 1 2)
		  ;; => false
		  
		  (number? 1984)
		  ;; => true
		  (string? "123")
		  ;; => true
		  (keyword? :test)
		  ;; => true
		  (map? {:title 1984})
		  ;; => true
		  (vector? [1984])
		  ;; => true
		  
		  ;; Charge extra if it's an express order or oversized
		  ;; and they are not a preferred customer.
		  (defn shipping-surcharge? [preferred-customer express oversized]
		    (and (not preferred-customer) (or express oversized)))
		  (shipping-surcharge? false true true)
		  ;; => true
		  
		  
		  ;; Truthy and Falsy
		  
		  
		  (if 1 true false)
		  ;; => true
		  (if "hello" true false)
		  ;; => true
		  (if [1 2 3] true false)
		  ;; => true
		  (if "" true false)
		  ;; => true
		  (if 0 true false)
		  ;; => true
		  (if -1 true false)
		  ;; => true
		  
		  ;; only these 2 are falsy
		  (if false true false)
		  ;; => false
		  (if nil true false)
		  ;; => false
		  
		  
		  ;; Do and when
		  
		  
		  (do
		    (println "This is four expressions")
		    (println "All grouped together as one")
		    (println "That prints some stuff and then evaluates to 44")
		    44)
		  ;; => 44
		  
		  (let [preffered-customer true]
		    #_{:clj-kondo/ignore [:unused-value]}
		    (when preffered-customer
		      "Hello returncing customer!"
		      "Welcome back to Blotts Books!"))
		  ;; => "Welcome back to Blotts Books!"
		  
		  ;; else is just a normal keyword which evaluated as a truthy value
		  (defn shipping-charge [preffered-customer order-amount]
		    (cond
		      preffered-customer 0.0
		      (< order-amount 50.0) 5.0
		      (< order-amount 100.0) 10.0
		      :else (* 0.1 order-amount)))
		  (shipping-charge false 101)
		  ;; => 10.100000000000001
		  
		  (defn customer-greeting [status]
		    (case status
		      :gold "Welcome, welcome, welcome back!!!"
		      :preffered "Welcome back!"
		      "Welcome to Blotts Books"))
		  (customer-greeting :gold)
		  ;; => "Welcome, welcome, welcome back!!!"
		  (customer-greeting :preffered)
		  ;; => "Welcome back!"
		  (customer-greeting nil)
		  ;; => "Welcome to Blotts Books"
		  
		  
		  ;; Throwing and catching
		  
		  ;; (/ 0 0)
		  ;; => Execution error (ArithmeticException) at follow-along.c04-logic/eval15484 (form-init4924825596685870731.clj:127).
		  ;;    Divide by zero
		  
		  1
		  ;; => 1
		  
		  (try
		    (/ 1 0)
		    (catch ArithmeticException _ (println "Math problem."))
		    (catch StackOverflowError _ (println "Unable to publish..")))
		  ;; => nil
		  
		  
		  (defn publish-book [book]
		    (when (not (:title book))
		      (throw (ex-info "A book needs a title!" {:book book})))
		    ;; Lots of publishing stuff..
		    )
		  (publish-book {:title "Teletubbies"})
		  ;; => nil
		  ;; (publish-book {:author "super author"})
		  ;; => Execution error (ExceptionInfo) at follow-along.c04-logic/publish-book (form-init4924825596685870731.clj:143).
		  ;;    A book needs a title!
		  
		  
		  (try (publish-book {:author "Hurra!"})
		       (catch clojure.lang.ExceptionInfo _  "Exception successfully catched!"))
		  ;; => "Exception successfully catched!"
		  
		  
		  ;; In the wild
		  
		  
		  (defn ensure-task-is-a-vector [task]
		    (if (vector? task)
		      task
		      [task]))
		  (ensure-task-is-a-vector [1 2 3])
		  ;; => [1 2 3]
		  (ensure-task-is-a-vector '(1 2 3))
		  ;; => [(1 2 3)]
		  
		  
		  ;; Staying out of trouble
		  
		  
		  (and true 1984)
		  ;; => 1984
		  (and 2001 "Emma")
		  ;; => "Emma"
		  (and 2001 nil "Emma")
		  ;; => nil
		  
		  ```
- Chapter 5 - More Capable Functions
	- Multimethod addition does not have to appear in the same file or be written by the same programmer as the originals. And this means Multimethods provide a great extension point for your code.
	- Loop and recur
		- ```clojure
		  (def books
		    [{:title  "Jaws"   :copies-sold 2000000}
		     {:title  "Emma"   :copies-sold 3000000}
		     {:title  "2001"   :copies-sold 4000000}])
		  
		  (defn sum-copies
		    ([books] (sum-copies books 0))
		    ([books total]
		     (if (empty? books)
		       total
		       (sum-copies
		        (rest books)
		        (+ total (:copies-sold (first books)))))))
		  (sum-copies books)
		  ;; => 9000000
		  
		  (defn better-sum-copies [books]
		    (loop [books books total 0]
		      (if (empty? books)
		        total
		        (recur
		         (rest books)
		         (+ total (:copies-sold (first books)))))))
		  (better-sum-copies books)
		  ;; => 9000000
		  ```
		- The way to understand loop is to think of it as a blend of a phantom function and a call to that function. In our example, the “function” has two parameters, books and total, which initially get bound to the original book collection and 0. With books and total bound, we evaluate the body, in this case the if expression. The trick is that loop works with recur. When it hits a recur inside the body of a loop, Clojure will reset the values bound to the symbols to values passed into recur and then recursively reevaluate the loop body.
		- The second thing is that recur is a reasonably low-level tool. Chances are there is a better—and easier—way to get your task done. If, for example, you need to add up all those book sales, you would probably say something like this:
			- ```clojure
			  (defn even-better-sum-copies [books] (apply + (map :copies-sold books)))
			  (even-better-sum-copies books)
			  ;; => 9000000
			  ```
	- Code snippets
		- ```clojure
		  (ns follow-along.c05-more-capable-functions
		    (:require [clojure.repl :refer [doc]]))
		  
		  ;; One function, different parameters
		  
		  
		  (defn greet1
		    ([to-whom] (str "Welcome to Blotts Books" " " to-whom))
		    ([message to-whom] (str message " " to-whom)))
		  (greet1 "it may concern")
		  ;; => "Welcome to Blotts Books it may concern"
		  (greet1 "hola" "it may concern")
		  ;; => "hola it may concern"
		  
		  (defn greet
		    ([to-whom] (greet "Welcome to Blotts Books" to-whom))
		    ([message to-whom] (str message " " to-whom)))
		  
		  (greet "it may concern")
		  ;; => "Welcome to Blotts Books it may concern"
		  (greet "hola" "it may concern")
		  ;; => "hola it may concern"
		  
		  
		  ;; Arguments with wild abandon
		  
		  
		  (defn print-any-args [& args]
		    (str "My arguments are:" " " args))
		  (print-any-args 7 true nil)
		  ;; => "My arguments are: (7 true nil)"
		  
		  (defn first-argument [& args]
		    (first args))
		  (first-argument 1 2 3 4)
		  ;; => 1
		  
		  (defn new-first-argument [x & _] x)
		  (new-first-argument 4 3 2 1)
		  ;; => 4
		  
		  
		  ;; Multimethods
		  
		  (def book ["War and Peace"  "Tolstoy"])
		  (defn normalize-book-1 [book]
		    (if (vector? book)
		      {:title (first book) :author (second book)}
		      (if (contains? book :title)
		        book
		        {:title (:book book) :author (:by book)})))
		  (normalize-book-1 book)
		  ;; => {:title "War and Peace", :author "Tolstoy"}
		  
		  (defn dispatch-book-format [book]
		    (cond
		      (vector? book) :vector-book
		      (contains? book :title) :standard-map
		      (contains? book :book) :alternative-map))
		  (defmulti normalize-book dispatch-book-format)
		  (defmethod normalize-book :vector-book [book]
		    {:title (first book) :author (second book)})
		  (defmethod normalize-book :standard-map [book]
		    book)
		  (defmethod normalize-book :alternative-map [book]
		    {:title (:book book) :author (:by book)})
		  (normalize-book {:title "War and Peace" :author "Tolstoy"})
		  ;; => {:title "War and Peace", :author "Tolstoy"}
		  (normalize-book {:book "War and Peace" :by "Tolstoy"})
		  ;; => {:title "War and Peace", :author "Tolstoy"}
		  (normalize-book ["War and Peace" "Tolstoy"])
		  ;; => {:title "War and Peace", :author "Tolstoy"}
		  
		  
		  (def books-1 [{:title  "Pride and Prejudice"  :author  "Austen"  :genre :romance}
		                {:title  "World War Z"  :author  "Brooks"  :genre :zombie}])
		   	;; Remember you can use keys like :genre like functions on maps.
		  (defmulti book-description :genre)
		  (defmethod book-description :romance [book]
		    (str  "The heart warming new romance by "  (:author book)))
		  (defmethod book-description :zombie [book]
		    (str  "The heart consuming new zombie adventure by "  (:author book)))
		  (book-description (first books-1))
		  ;; => "The heart warming new romance by Austen"
		  (book-description (second books-1))
		  ;; => "The heart consuming new zombie adventure by Brooks"
		  (def ppz {:title  "Pride and Prejudice and Zombies"
		            :author "Grahame-Smith"
		            :genre :zombie-romance})
		  (defmethod book-description :zombie-romance [book]
		    (str  "The heart warming and consuming new romance by "  (:author book)))
		  (book-description ppz)
		  ;; => "The heart warming and consuming new romance by Grahame-Smith"
		  
		  
		  ;; Deeply recursive
		  
		  
		  (def books
		    [{:title  "Jaws"   :copies-sold 2000000}
		     {:title  "Emma"   :copies-sold 3000000}
		     {:title  "2001"   :copies-sold 4000000}])
		  (defn sum-copies
		    ([books] (sum-copies books 0))
		    ([books total]
		     (if (empty? books)
		       total
		       (sum-copies
		        (rest books)
		        (+ total (:copies-sold (first books)))))))
		  (sum-copies books)
		  ;; => 9000000
		  
		  (defn better-sum-copies [books]
		    (loop [books books total 0]
		      (if (empty? books)
		        total
		        (recur
		         (rest books)
		         (+ total (:copies-sold (first books)))))))
		  (better-sum-copies books)
		  ;; => 9000000
		  
		  (defn even-better-sum-copies [books] (apply + (map :copies-sold books)))
		  (even-better-sum-copies books)
		  ;; => 9000000
		  
		  
		  ;; Docstring
		  
		  (defn average
		    "Return the average of the two parameters"
		    [a b]
		    (/ (+ a b) 2.0))
		  (average 10 20)
		  ;; => 15.0
		  
		  (defn multi-average
		    "return the average of 2 or 3 numbers"
		    ([a b]
		     (/ (+ a b) 2.0))
		    ([a b c]
		     (/ (+ a b c) 3.0)))
		  (multi-average 10 20)
		  ;; => 15.0
		  (multi-average 10 20 30)
		  ;; => 20.0
		  
		  (doc multi-average)
		  
		  (defn- print-book [_])
		  (defn- ship-book [_])
		  
		  #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]}
		  (defn publish-book-old [book]
		    (when-not (contains? book :title)
		      (throw (ex-info "Books must contain :title" {:book book})))
		    (print-book book)
		    (ship-book book))
		  
		  #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]}
		  (defn publish-book-with-pre [book]
		    {:pre [(:title book)]}
		    (print-book book)
		    (ship-book book))
		  ;; the value should be vector-expression for :pre condition
		  
		  (defn publish-book [book]
		    {:pre [(:title book) (:author book)]
		     :post [(boolean? %)]}
		    (print-book book)
		    (ship-book book)
		    (boolean? book))
		  
		  ;; (publish-book {:title "Yo"})
		  ;; => Execution error (AssertionError) at follow-along.c05-more-capable-functions/publish-book (c05_more_capable_functions.clj:168).
		  ;;    Assert failed: (:author book)
		  
		  (publish-book {:title "Yo" :author 122})
		  ;; => false
		  ```
- Chapter 6 - Functional Things
	- Code snippets
		- ```clojure
		  (ns follow-along.c06-functional-things)
		  
		  ;; Functions are values
		  
		  
		  (def dracula {:title "Dracula"
		                :author "Stoker"
		                :price 1.99
		                :genre :horror})
		  (defn cheap? [book]
		    (when (<= (:price book) 9.99)
		      book))
		  (defn pricey? [book]
		    (when (> (:price book) 9.99)
		      book))
		  (cheap? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (pricey? dracula)
		  ;; => nil
		  
		  (defn horror? [book]
		    (when (= (:genre book) :horror)
		      book))
		  (defn adventure? [book]
		    (when (= (:genre book) :adventure)
		      book))
		  (horror? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (adventure? dracula)
		  ;; => nil
		  
		  (defn cheap-horror? [book]
		    (when (and (cheap? book)
		               (horror? book))
		      book))
		  (defn pricy-adventure? [book]
		    (when (and (pricey? book)
		               (adventure? book))
		      book))
		  (cheap-horror? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (pricy-adventure? dracula)
		  ;; => nil
		  
		  (def reasonably-priced? cheap?)
		  (reasonably-priced? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  
		  (defn run-with-dracula [f]
		    (f dracula))
		  (run-with-dracula pricey?)
		  ;; => nil
		  (run-with-dracula horror?)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  
		  (defn both? [first-predicate-f second-predicate-f book]
		    (when (and (first-predicate-f book)
		               (second-predicate-f book))
		      book))
		  (both? cheap? horror? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (both? pricey? adventure? dracula)
		  ;; => nil
		  
		  
		  ;; Functions on the fly
		  
		  (fn [n] (* 2 n))
		  (str "A function:" (fn [n] (* 2 n)))
		  ;; => "A function:follow_along.c06_functional_things$eval7991$fn__7992@d5cc0de"
		  (def double-it (fn [n] (* 2 n)))
		  (double-it 10)
		  ;; => 20
		  ((fn [n] (* 2 n)) 10)
		  ;; => 20
		  
		  (defn cheaper-f [max-price]
		    (fn [book]
		      (when (<= (:price book) max-price)
		        book)))
		  ;; define some helpful functions.
		  (def real-cheap? (cheaper-f 1.00))
		  (def kind-of-cheap? (cheaper-f 1.99))
		  (def marginally-cheap? (cheaper-f 5.99))
		  (real-cheap? dracula)
		  ;; => nil
		  (kind-of-cheap? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (marginally-cheap? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  
		  (defn both-f [first-predicate-f second-predicate-f]
		    (fn [book]
		      (when (and (first-predicate-f book)
		                 (second-predicate-f book))
		        book)))
		  (def cheap-horror-1? (both-f cheap? horror?))
		  (def real-cheap-adventure? (both-f real-cheap? adventure?))
		  (def real-cheap-horror? (both-f real-cheap? horror?))
		  (cheap-horror-1? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (real-cheap-adventure? dracula)
		  ;; => nil
		  (real-cheap-horror? dracula)
		  ;; => nil
		  
		  (def cheap-horror-possession?
		    (both-f cheap-horror?
		            (fn [book] (= (:title book) "Possession"))))
		  (cheap-horror-possession? dracula)
		  ;; => nil
		  
		  
		  ;; A functional toolkit
		  
		  (+ 1 2 3 4)
		  ;; => 10
		  
		  (def the-function +)
		  (def args [1 2 3 4])
		  (apply the-function args)
		  ;; => 10
		  
		  (def v ["The number " 2 " best selling " "book."])
		  (apply str v)
		  ;; => "The number 2 best selling book."
		  (apply list v)
		  ;; => ("The number " 2 " best selling " "book.")
		  (apply vector (apply list v))
		  ;; => ["The number " 2 " best selling " "book."]
		  
		  (defn my-inc [n] (+ 1 n))
		  (def my-inc-p (partial + 1))
		  (my-inc 2)
		  ;; => 3
		  (my-inc-p 2)
		  ;; => 3
		  
		  
		  (defn cheaper-than [max-price book]
		    (when (<= (:price book) max-price)
		      book))
		  (def real-cheap-p? (partial cheaper-than 1.00))
		  (def kind-of-cheap-p? (partial cheaper-than 1.99))
		  (def marginally-cheap-p? (partial cheaper-than 5.99))
		  (real-cheap-p? dracula)
		  ;; => nil
		  (kind-of-cheap-p? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (marginally-cheap-p? dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  
		  (defn adventure-p? [book]
		    (when (= (:genre book) :adventure)
		      book))
		  (defn not-adventure? [book] (not (adventure-p? book)))
		  (def not-adventure-c? (complement adventure-p?))
		  (not-adventure? dracula)
		  ;; => true
		  (not-adventure-c? dracula)
		  ;; => true
		  
		  ;; (def cheap-horror-2? (every-pred cheap? horror?))
		  (def cheap-horror-possession-e?
		    (every-pred
		     cheap?
		     horror?
		     (fn [book] (= (:title book) "Possession"))))
		  (cheap-horror-possession-e? dracula)
		  ;; => false
		  
		  
		  ;; Function literals
		  
		  (#(when (= (:genre %1) :horror) %1) dracula)
		  ;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
		  (#(+ %1 %2 %3) 1 2 3)
		  ;; => 6
		  (#(count %) "Count this string length")
		  ;; => 24
		  
		  
		  ;; In the wild
		  
		  (defn say-welcome [what]
		    (str "Welcome to " what "!"))
		  (def say-welcome-with-def
		    (fn [what] (str "Welcome to " what "!")))
		  (say-welcome "home")
		  ;; => "Welcome to home!"
		  (say-welcome-with-def "home")
		  ;; => "Welcome to home!"
		  
		  (def book {:title "Emma" :copies 1000})
		  book
		  ;; => {:title "Emma", :copies 1000}
		  (update book :copies inc)
		  ;; => {:title "Emma", :copies 1001}
		  
		  (def by-author
		    {:name "Jane Austen"
		     :book {:title "Emma" :copies 1000}})
		  (update-in by-author [:book :copies] inc)
		  ;; => {:name "Jane Austen", :book {:title "Emma", :copies 1001}}
		  ```
- Chapter 7 - Let
	- Code snippets
		- ```clojure
		  (ns follow-along.ch07-let)
		  
		  
		  ;; ---
		  ;; A local, temporary place for your stuff
		  ;; ---
		  
		  (defn compute-discount-amount-original [amount discount-percent min-charge]
		    (if (> (* amount (- 1.0 discount-percent)) min-charge)
		      (* amount (- 1.0 discount-percent))
		      min-charge))
		  (compute-discount-amount-original 1 2 3)
		  ;; => 3
		  
		  (defn compute-discount-amount [amount discount-percent min-charge]
		    (let [discount (* amount discount-percent)
		          discounted-amount (- amount discount)]
		      (println  "Discount:"  discount)
		      (println  "Discounted amount"  discounted-amount)
		      (if (> discounted-amount min-charge)
		        discounted-amount
		        min-charge)))
		  (compute-discount-amount 1 2 3)
		  ;; => 3
		  
		  (def user-discounts
		    {"Nicholas"  0.10  "Jonathan"  0.07  "Felicia"  0.05})
		  (defn mk-discount-price-f [user-name user-discounts min-charge]
		    (let [discount-percent (user-discounts user-name)]
		      (fn [amount]
		        (let [discount (* amount discount-percent)
		              discounted-amount (- amount discount)]
		          (if (> discounted-amount min-charge)
		            discounted-amount
		            min-charge)))))
		  ;; get a price function for Felicia
		  (def computer-felicia-price (mk-discount-price-f "Felicia" user-discounts 10.0))
		  ;; ...and sometime later compute a price
		  (computer-felicia-price 20.0)
		  ;; => 19.0
		  
		  
		  ;; Variations on the Theme
		  
		  
		  (def anonymous-book
		    {:title "Sir Gawain and the Green Knight"})
		  (def with-author
		    {:title "Once and Future King" :author "White"})
		  (defn uppercase-author [book]
		    (let [author (:author book)]
		      (if author
		        (.toUpperCase author)
		        "ANONYMOUS")))
		  (uppercase-author anonymous-book)
		  ;; => "ANONYMOUS"
		  (uppercase-author with-author)
		  ;; => "WHITE"
		  
		  (defn uppercase-author-iflet [book]
		    (if-let [author (:author book)]
		      (.toUpperCase author) "ANONYMOUS"))
		  (uppercase-author-iflet anonymous-book)
		  ;; => "ANONYMOUS"
		  (uppercase-author-iflet with-author)
		  ;; => "WHITE"
		  
		  
		  (defn uppercase-author-whenlet [book]
		    (when-let [author (:author book)]
		      (.toUpperCase author)))
		  (uppercase-author-whenlet anonymous-book)
		  ;; => nil
		  (uppercase-author-whenlet with-author)
		  ;; => "WHITE"
		  ```
- Chapter 8 - Def, Symbols, Vars
	- If vars are all about providing a global, stable environment for your code, you might wonder why vars are mutable. After all, Clojure loves immutability. But we can def and re-def our vars with wild abandon. The answer is as simple as it is pragmatic: mutable vars make for more productive Clojure programmers. Most Clojure programming is done in some form of REPL or other. While your code is under development, mutable vars are a gift from heaven.
		- Things are different in production. The vars in a production program are just as mutable as those in development, but you should avoid changing them. In production code, you should `def` (and `defn`) things and let them be.
	- One thing to keep in mind is that let does not create vars.
	- Code snippets
		- ```clojure
		  (ns follow-along.ch08-def-symbols-vars)
		  
		  ;; A global, stable place for your stuff
		  
		  (def title "Emma")
		  (def PI 3.14)
		  (def ISBN-LENGTH 13)
		  (def COMPANY-NAME "Blotts Books")
		  
		  
		  (defn book-description [book]
		    (str (:title book)
		         " Written by "
		         (:author book)))
		  (def book-description
		    (fn [book]
		      (str (:title book)
		           " Written by "
		           (:author book))))
		  
		  (def OLD-ISBN-LENGTH 10)
		  (def isbn-lengths [OLD-ISBN-LENGTH ISBN-LENGTH])
		  (defn valid-isbn [isbn]
		    (or (= (count isbn) OLD-ISBN-LENGTH)
		        (= (count isbn) ISBN-LENGTH)))
		  
		  ;; Symbols are things
		  
		  ;; string "Austen" and the symbol author
		  (def author "Austen")
		  'author
		  ;; => author
		  (str 'author)
		  ;; => "author"
		  
		  (= 'author 'some-other-symbol)
		  ;; => false
		  (= 'title 'title)
		  ;; => true
		  ```
- Chapter 9 - Namespaces
	- Along with the namespace-to-file-name transformation, Clojure also relies on the Java class path—essentially a list of places that the JVM looks for code—to help it locate namespaces. This is how Clojure knows to look in the src directory, and how it manages to locate the built-in Clojure library code. More on this in ((63dd196e-c1db-4ccf-b0b3-030ea7f9fc1f)) .
	- REPLs generally include the name of the current namespace in their prompts. If you start a REPL with Leiningen outside of a project directory, your initial namespace will be `user`, and that’s what you will see in your prompt. On the other hand, if you start a REPL from inside of a Clojure project directory, Leiningen will default to the `core` namespace of that project.
	- Code snippets
		- ```clojure
		  (ns follow-along.ch09-namespaces
		    (:require
		     clojure.data
		     [follow-along.pricing :as pricing
		      :refer [discount-rate]]))
		  
		  ;; A place for your vars
		  
		  (pricing/discount-price {:title  "Emma"  :price 9.99})
		  ;; => 8.4915
		  
		  ;; => 8.4915
		  
		  ;; Loading namespaces
		  
		  (def literature ["Emma" "Oliver Twist" "Possession"])
		  (def horror ["It" "Carry" "Possession"])
		  
		  (clojure.data/diff literature horror)
		  ;; => [["Emma" "Oliver Twist"] ["It" "Carry"] [nil nil "Possession"]]
		  
		  
		  discount-rate
		  ;; => 0.15
		  
		  ;; Namespaces, symbols, and keywords
		  
		  (str "Current ns:" *ns*)
		  ;; => "Current ns:follow-along.ch09-namespaces"
		  
		  (ns-map (find-ns 'user)) ; include all the predefined vars
		  (ns-map 'user) ; do the same as above
		  
		  discount-rate
		  ;; => 0.15
		  (ns-unmap *ns* 'discount-rate)
		  ;; discount-rate
		  ;; error
		  
		  ;; don't execute it more than once
		  ;; :reload will not affect this
		  ;; change it with ns-unmap
		  ;; (defonce some-value (function-with-side-effects))
		  ```
- Chapter 10 - Sequences
	- Functions like sort, reverse, partition, interleave, and interpose all share the same basic processing skeleton. They start by turning their collection arguments into sequences with `seq`. They then do their thing using only `first`, `rest`, and `cons`, or using functions that rely on the magic foursome. Finally, they return the result as—you guessed it—a sequence.
	- Code snippets
		- ```clojure
		  (ns follow-along.ch10-sequences
		    (:require [clojure.java.io :as io]))
		  
		  ;; one thing after another
		  
		  (defn flavor [x]
		    (cond
		      (list? x) :list
		      (vector? x) :vector
		      (set? x) :set
		      (map? x) :map
		      (string? x) :string
		      :else :unknown))
		  (defmulti my-count-old flavor)
		  (defn- list-specific-count [x] x)
		  (defn- vector-specific-count [x] x)
		  (defmethod my-count-old :list [x]
		    (list-specific-count x))
		  (defmethod my-count-old :vector [x]
		    (vector-specific-count x))
		  
		  (def title-seq (seq ["Emma"   "Oliver Twist"   "Robinson Crusoe"]))
		  title-seq
		  ;; => ("Emma" "Oliver Twist" "Robinson Crusoe")
		  (seq '("Emma"   "Oliver Twist"   "Robinson Crusoe"))
		  ;; => ("Emma" "Oliver Twist" "Robinson Crusoe")
		  (seq {:title  "Emma" , :author  "Austen" , :published 1815})
		  ;; => ([:title "Emma"] [:author "Austen"] [:published 1815])
		  
		  ;; Calling seq on a sequence is a noop.
		  (seq (seq ["Red Queen"   "The Nightingale"   "Uprooted"]))
		  ;; => ("Red Queen" "The Nightingale" "Uprooted")
		  
		  (seq [])
		  ;; => nil
		  (seq '())
		  ;; => nil
		  (seq {})
		  ;; => nil
		  
		  ;; A universal interface
		  
		  (first title-seq)
		  ;; => "Emma"
		  (rest title-seq)
		  ;; => ("Oliver Twist" "Robinson Crusoe")
		  (cons "Emma" (rest title-seq))
		  ;; => ("Emma" "Oliver Twist" "Robinson Crusoe")
		  
		  (defn my-count [col]
		    (let [the-seq (seq col)]
		      (loop [n 0 s the-seq]
		        (if (seq s)
		          (recur (inc n) (rest s))
		          n))))
		  (my-count '(1 2 3))
		  ;; => 3
		  
		  ;; rest function always returns a sequence
		  (rest [1 2 3])
		  ;; => (2 3)
		  (rest {:fname "Jane" :lname "Austen"})
		  ;; => ([:lname "Austen"])
		  (next {:fname "Jane" :lname "Austen"})
		  ;; => ([:lname "Austen"])
		  (cons 0 [1 2 3])
		  ;; => (0 1 2 3)
		  (cons 0 #{1 2 3})
		  ;; => (0 1 3 2)
		  
		  ;; A rich toolkit
		  
		  (def titles ["Jaws"   "Emma"   "2001"  "Dracula"])
		  (sort titles)
		  ;; => ("2001" "Dracula" "Emma" "Jaws")
		  (reverse titles)
		  ;; => ("Dracula" "2001" "Emma" "Jaws")
		  (reverse (sort titles))
		  ;; => ("Jaws" "Emma" "Dracula" "2001")
		  
		  (def titles-and-authors ["Jaws"   "Benchley"   "2001"   "Clarke"])
		  (partition 2 titles-and-authors)
		  ;; => (("Jaws" "Benchley") ("2001" "Clarke"))
		  (partition 3 titles-and-authors)
		  ;; => (("Jaws" "Benchley" "2001"))
		  
		  (def titles-2  ["Jaws"   "2001"])
		  (def authors-2 '("Benchley"   "Clarke"))
		  (interleave titles-2 authors-2)
		  ;; => ("Jaws" "Benchley" "2001" "Clarke")
		  (interleave titles authors-2)
		  ;; => ("Jaws" "Benchley" "Emma" "Clarke")
		  
		  (def scary-animals ["Lions" "Tigers" "Bears"])
		  (interpose "and" scary-animals)
		  ;; => ("Lions" "and" "Tigers" "and" "Bears")
		  
		  ;; Made richer with functional values
		  
		  (filter neg? '(1 -22 3 -99 4 5 6 -77))
		  ;; => (-22 -99 -77)
		  
		  (def books
		    [{:title  "Deep Six"  :price 13.99 :genre :sci-fi :rating 6 :sales 1}
		     {:title  "Dracula"  :price 1.99 :genre :horror :rating 7 :sales 1}
		     {:title  "Emma"  :price 7.99 :genre :comedy :rating 9 :sales 1}
		     {:title  "2001"  :price 10.50 :genre :sci-fi :rating 5 :sales 1}])
		  (defn cheap? [book]
		    (when (<= (:price book) 9.99)
		      book))
		  ;; find all the inexpensive book
		  (filter cheap? books)
		  ;; => ({:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  ;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9, :sales 1})
		  (some cheap? books)
		  ;; => {:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  (every? cheap? books)
		  ;; => false
		  (if (some cheap? books)
		    "We have cheap books for sale!"
		    "Expensive is the new cheap")
		  ;; => "We have cheap books for sale!"
		  
		  ;; Map
		  
		  (def some-numbers [1, 53, 811])
		  (def doubled (map #(* 2 %) some-numbers))
		  doubled
		  ;; => (2 106 1622)
		  
		  (map (fn [book] (:title book)) books)
		  ;; => ("Deep Six" "Dracula" "Emma" "2001")
		  (map :title books)
		  ;; => ("Deep Six" "Dracula" "Emma" "2001")
		  
		  (map (fn [book] (count (:title book))) books)
		  ;; => (8 7 4 4)
		  (map (comp count :title) books)
		  ;; => (8 7 4 4)
		  (for [b books]
		    (count (:title b)))
		  ;; => (8 7 4 4)
		  
		  ;; Reduce
		  
		  (def numbers [10 20 30 40 50])
		  (defn add2 [a b] (+ a b))
		  (reduce add2 0 numbers)
		  ;; => 150
		  (reduce + 0 numbers)
		  ;; => 150
		  
		  ;; if we omit the initial value form the call to reduce
		  ;; reduce will use the first element of the collection as the initial value
		  (reduce + numbers)
		  ;; => 150
		  
		  (defn hi-price [hi book]
		    (if (> (:price book) hi)
		      (:price book)
		      hi))
		  (reduce hi-price 0 books)
		  ;; => 13.99
		  
		  ;; Composing a solution
		  
		  books
		  ;; => [{:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6, :sales 1}
		  ;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  ;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9, :sales 1}
		  ;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5, :sales 1}]
		  (sort-by :rating books)
		  ;; => ({:title "2001", :price 10.5, :genre :sci-fi, :rating 5, :sales 1}
		  ;;     {:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6, :sales 1}
		  ;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  ;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9, :sales 1})
		  (reverse (sort-by :rating books))
		  ;; => ({:title "Emma", :price 7.99, :genre :comedy, :rating 9, :sales 1}
		  ;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  ;;     {:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6, :sales 1}
		  ;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5, :sales 1})
		  (take 3 (reverse (sort-by :rating books)))
		  ;; => ({:title "Emma", :price 7.99, :genre :comedy, :rating 9, :sales 1}
		  ;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7, :sales 1}
		  ;;     {:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6, :sales 1})
		  (map :title (take 3 (reverse (sort-by :rating books))))
		  ;; => ("Emma" "Dracula" "Deep Six")
		  (interpose " // " (map :title (take 3 (reverse (sort-by :rating books)))))
		  ;; => ("Emma" " // " "Dracula" " // " "Deep Six")
		  (apply str
		         (interpose " // "
		                    (map :title (take 3 (reverse (sort-by :rating books))))))
		  ;; => "Emma // Dracula // Deep Six"
		  
		  ;; Other sources of sequences
		  
		  ;; Authors.txt contains
		  ;; Emma
		  ;; Dracula
		  ;; Deep Six
		  (defn listed-author? [author]
		    (with-open [r (io/reader  "authors.txt")]
		      (some (partial = author) (line-seq r))))
		  (listed-author? "Emma")
		  ;; => true
		  (listed-author? "Emmas")
		  ;; => nil
		  
		  ;; A regular expression that matches Pride and Prejudice followed by anything.
		  (def re #"Pride and Prejudice.*")
		   	;; A string that may or may not match.
		  (def title  "Pride and Prejudice and Zombies")
		   	;; And we have a classic!
		  (if (re-matches  re title)
		    "We have a classic!"
		    "No classic for you!")
		  ;; => "We have a classic!"
		  (if (re-matches  #"Pride and Prejudice.*" title)
		    "We have a classic!"
		    "No classic for you!")
		  ;; => "We have a classic!"
		  
		  ;; regex #"\w+" matches a single word
		  (re-seq #"\w+" title)
		  ;; => ("Pride" "and" "Prejudice" "and" "Zombies")
		  
		  
		  ;; in the wild
		  
		  (apply str
		         (interpose " // "
		                    (map :title (take 3 (reverse (sort-by :rating books))))))
		  ;; => "Emma // Dracula // Deep Six"
		  
		  ;; there is no performance penalty on using ->>
		  (->> books
		       (sort-by :rating)
		       reverse
		       (take 3)
		       (map :title)
		       (interpose " // ")
		       (apply str))
		  ;; => "Emma // Dracula // Deep Six"
		  
		  ;; ->> : pipe last
		  ;; -> : pipe first
		  (->> 1
		       (- 1))
		  ;; => 0
		  (-> 1
		      (- 1))
		  ;; => 0
		  
		  ;; Staying out of trouble
		  
		  (defn total-sales-recur [books]
		    (loop [books books total 0]
		      (if (empty? books)
		        total
		        (recur (next books)
		               (+ total (:sales (first books)))))))
		  (defn total-sales [books]
		    (apply + (map :sales books)))
		  (total-sales-recur books)
		  ;; => 4
		  (total-sales books)
		  ;; => 4
		  
		  (def maze-runner {:title  "The Maze Runner"  :author  "Dashner"})
		  
		  (:author maze-runner)
		  ;; => "Dashner"
		  (seq maze-runner)
		  ;; => ([:title "The Maze Runner"] [:author "Dashner"])
		  (:author (seq maze-runner))
		  ;; => nil
		  (rest maze-runner)
		  ;; => ([:author "Dashner"])
		  (:author (rest maze-runner))
		  ;; => nil
		  
		  (conj ["Emma"   "1984"   "The Maze Runner"]  "Jaws")
		  ;; => ["Emma" "1984" "The Maze Runner" "Jaws"]
		  (conj '("Emma"   "1984"   "The Maze Runner")  "Jaws")
		  ;; => ("Jaws" "Emma" "1984" "The Maze Runner")
		  (cons  "Jaws"  ["Emma"   "1984"   "The Maze Runner"])
		  ;; => ("Jaws" "Emma" "1984" "The Maze Runner")
		  (cons  "Jaws"  '("Emma"   "1984"   "The Maze Runner"))
		  ;; => ("Jaws" "Emma" "1984" "The Maze Runner")
		  ```
- Chapter 11 - Lazy Sequences
	- Lazy sequence is one that waits to be asked before it generates its elements.
	- An unbounded sequence is a lazy sequence that, in theory, can go forever.
	- Code snippets
		- ```clojure
		  ```
- Chapter 12 - Destructuring
- Chapter 13 - Records and Protocols
- Chapter 14 - Tests
- Chapter 15 - Spec
- Chapter 16 - Interoperating with Java
  id:: 63dd196e-c1db-4ccf-b0b3-030ea7f9fc1f
- Chapter 17 - Threads, Promises, and Futures
- Chapter 18 - State
- Chapter 19 - Read and Eval
- Chapter 20 - Macros
- Chapter 21 - Conclusion