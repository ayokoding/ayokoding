content-channels:: [[YouTube]]
content-origin:: external
content-status:: wip
content-authors:: [[Joe Armstrong]]
lang:: en
type:: content

- {{video https://www.youtube.com/watch?v=TTM_b7EJg5E}}
- Topics
	- [[Fault-tolerant]]
	- [[Error Handling]]
	- [[Erlang]]
- Related links
	- [Original slide](https://files.gotocon.com/uploads/slides/conference_9/352/original/do_dont_error_handling.pdf)
- Summary
	- A system is fault tolerant if it continues working if something is wrong
	- Things to note
		- Hardware can fail => relatively uncommon
		- Software can fail => common
	- Overview
		- Fault tolerance cannot be achieved using a single computer
			- It might fail
		- We have touse several computers
			- Concurrency
			- Parallel programming
			- Distributed programming
			- Physics
			- Engineering
			- Message passing is inevitable
		- Programming languages should make this ~~easy~~ doable
		- How individual computers work is the smaller problem
		- How the computers are interconnected and the protocols used between the computers is the significant problem.
		- We want the same way to program large and small scale systems
	- Message passing is inevitable
		- ((63ce685f-9016-4db6-ae18-910474b3d68b))
		- [[C.A.R. Hoare - Communicating Sequential Processes\ (CSP)]]
		- [[Erlang]]
			- Derived from [[Smalltalk]] and [[Prolog]] (influences by ideas from [[C.A.R. Hoare - Communicating Sequential Processes\ (CSP)]] )
			- Unifies ideas on concurrent and functional programming.
			- Follows laws of physics ([[Asynchronous Messaging]])
			- Designed for programming [[Fault-tolerant]] systems.
		- Building [[Fault-tolerant]] software boils down to detecting errors and doing something when errors are detected.
		- Types of errors
			- Errors that can be detected at compile-time
			- Errors that can be detected at run-time
			- Errors that can be inferred
			- Reproducible errors
			- Non-reproducible errors
		- Philisophy
			- Find methods to prove software correct at compile-time.
			- Assume the software is incorrect and will fail at run time then do something about it at run-time.
		- Evidence for software failure is all around us.
		- Proving the self-consistency of small programs will not help
		- Proving things is difficult
			- Prove the [[Collatz conjecture]] (also known as the [[Ulam conjecture]], [[Kakutani’s problem]] , [[Thwaites conjecture]] , [[Hasse’s algorithm]] , or the [[Syracuse problem]])
			- [[3N+1]]
				- If N is odd, replace it by 3N+1
				- If N is even, replace it by N/2
				- [[Collatz conjecture]]
					- This process will eventually reach the number 1, for all starting values on N.
			- Conclusion
				- Some small things can be proven to be self-consistent.
				- Large assemblies of small things are impossible to prove correct.
		- [[Erlang]] Timeline
		- [[Viking Program]]
			- Incorrect software is not an option
		- Types of system
			- Highly reliable
				- Example
					- Nuclear power plant control
					- Air traffic
					- Satellite
				- Very expensive if they fail
			- Reliable
				- Example
					- Driverless cars
				- Moderately expensive if they fail. Kills people if they fail
			- Reliable
				- Example
					- Banks
					- Telephone
				- Annoys people if they fail.
			- Dodgy
				- Example
					- Internet
					- HBO
					- Netflix
				- Cross if they fail
			- Crap
				- Example
					- Free apps
				- Very cross if they fail
		- How can we make software that works reasonably well even if there are errors in the software?
			- [[Joe Armstrong - Making reliable distributed systems in the presence of software errors]]
		- Requirements
			- R1 - Concurrency
			- R2 - Error encapsulation
			- R3 - Fault detection
			- R4 - Fault identification
			- R5 - Code upgrade
			- R6 - Stable storage
		- #wip
	- What's the big deal about concurrency?
		- #WIP
	- Why concurrent?
		- #WIP
	- Detecting errors
		- #WIP
	- Is that all?
		- #WIP
	- How do we descript contracts?
		- #wip